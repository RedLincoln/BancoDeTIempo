// Generated by Vue on Rails https://github.com/vueonrails/vueonrails
// Generate a component part with test by running command `rails generate vue something --test`

import {shallowMount, createLocalVue} from '@vue/test-utils'
import axios from 'axios'
import flushPromises from 'flush-promises'
import MockAdapter from 'axios-mock-adapter'
import App from '@/service_form.vue'
import Route from '../../app/javascript/routes'

jest.mock('../../app/javascript/routes');

describe('service_form.vue', () => {
    let mockAxios

    const editProps = {
        edit: true,
        id: 1
    }

    const serviceData = {
        name: 'Pintar',
        description: 'pintar exteriores e interioes'
    }

    const errorMessage = {
        name: 'Can not be blank',
        description: 'Can not be blank'
    }

    beforeEach(function () {
        mockAxios = new MockAdapter(axios);
    });

    it('no props means new service', () => {
        const wrapper = shallowMount(App)

        const name = wrapper.find('input#service_name')
        const description = wrapper.find('textarea#service_description')

        expect(name.text()).toBe('')
        expect(description.text()).toBe('')
    })

    it('editProps initial state', (done) => {
        const localVue = createLocalVue()
        const spy = jest.spyOn(axios, 'get')

        const wrapper = shallowMount(App, {
            propsData: editProps,
            localVue
        })

        mockAxios.onGet(Route.service_path(1)).reply(200, serviceData)

        setTimeout(() =>{
            expect(spy).toHaveBeenCalledTimes(1)
            expect(wrapper.vm.$data.name).toBe(serviceData.name)
            expect(wrapper.vm.$data.description).toBe(serviceData.description)
            done()
        })
    })

    it('show errors with the fields',  async () => {
        const wrapper = shallowMount(App)
        const spy = jest.spyOn(axios, 'post')

        mockAxios.onPost(Route.services_path()).reply(400, errorMessage)
        wrapper.find('input[type="submit"]').trigger('click')

        await flushPromises()

        const errors = wrapper.find('div#errors')
        expect(spy).toHaveBeenCalledTimes(1)
        expect(errors.exists()).toBe(true)
        expect(errors.find('.name').text()).toContain(errorMessage.name)
        expect(errors.find('.description').text()).toContain(errorMessage.description)

    })


})
